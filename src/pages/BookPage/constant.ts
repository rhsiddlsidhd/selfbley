import { BookReview } from "./type";

export const bookReviews: BookReview[] = [
  {
    id: "9791158394899",
    updatedAt: 20250923,
    author: "다이시 카토",
    title: "리액트 훅을 활용한 마이크로 상태 관리",
    description:
      "리액트와 같은 라이브러리를 사용하여 애플리케이션을 개발할 때, 상태 관리는 매우 중요한 부분입니다. 애니메이션의 상태 관리를 시작으로, 컴포넌트 간의 상태 공유, 비동기 데이터 처리 등 다양한 상황에서 상태 관리가 필요합니다. 상황에 따라 적절한 상태 관리 방법을 선택하는 것이 중요합니다. 다만, 그 선택하는 기준점을 잡지 못하고 상태 관리의 오남용될 때 다음에 유지보수의 어려움으로 다가올 수 있습니다. 이러한 오남용의 케이스는 지난 포트폴리오를 만드는 과정에서 문제점을 겪었던 경험이 있다. 많은 컴포넌트가 Animation을 사용하면서 순서를 제어해야 하는 케이스가 있었고 이를 여러 상태 관리로 나누지 않고 하나의 전역 상태로 관리했을 때 예상치 못한 버그가 많이 발생하였다. 당시에는 Animation의 순서를 보장하기 위해서 각 컴포넌트의 상태를 끌어올려서 부모 컴포넌트로부터 props를 내려주는 걸 택하였으나 많은 props drilling이 발생하여 이를 해결하기 위해 전역 상태 관리를 사용하였고, 이와 다른 컴포넌트들의 Animation 들 또한 같은 상태 관리로 묶어서 관리하였다. 이에 따라 상태가 변경될 때마다 불필요한 리렌더링이 발생하였고, 특정 컴포넌트의 상태가 변경되었을 때 다른 컴포넌트의 Animation이 의도치 않게 실행되는 버그가 발생하였다. 사실 당연한 결과였지만 당시에는 상태 관리에 대한 명확한 기준점이 없었기에 이러한 단순한 문제를 겪게 되었다. 경험을 바탕으로 전역 상태 값의 변경은 컴포넌트의 리렌더링을 일으킨다는 점을 인지하고, 전역 상태는 정말로 여러 컴포넌트에서 공유해야 하는 상태에만 사용하고, 그렇지 않은 상태는 각 컴포넌트 내부에서 지역 상태로 관리하여야 한다. 라는 원칙으로 삼게 되었다. 이 책은 전역 상태를 사용하는 경우를 두 가지 상황으로 일축하고 있다. 첫 번째는 prop의 전달이 적합하지 않을 때, 이 경우는 prop drilling이 발생한 경우를 이야기하며, 두 번째는 이미 리액트 외부에 상태가 있을 때, 인증의 경우를 이야기하고 있다. 인증 이외에도 테마 나 디바이스 크기 와 같은 걸 이야기한다고 보인다. 지난 경험으로 깨닫고 느낌적인 부분으로만 체득하고 있던 부분을, 책을 통해 문제점을 정의할 수 있게 되었다. 해당 책을 통해 전역 상태 관리 라이브러리들이 어떻게 동작하는지 이해를 돕고 각 라이브러리의 장단점을 파악하여 어떤 기준으로 비교하고 선택해야 하는지 그리고 전역 상태 관리 라이브러리를 사용할 때 최적화 방안까지 제시해 주고 있다. 경험이 적은 주니어 개발자로서 나는 그동안 러닝 커브가 낮고 현재 프론트엔드 개발에서 가장 많이 쓰이는 라이브러리라는 이유만으로 선택해 왔다. 하지만 이러한 기준만으로는 설득력이 부족하다고 느꼈다. 비록 많은 라이브러리를 직접 깊이 사용해 보지는 못했지만, 이 책을 통해 간접적으로 경험을 쌓으며 전역 상태 관리 라이브러리를 선택할 때 어떤 부분을 고려해야 하는지 더 설득력 있는 근거를 제시할 수 있지 않나 라는 생각을 하게 되었다. 책 한 권으로 모든 라이브러리를 이해하고 비교할 수는 없지만 그래도 이전보다는 나은 근거를 바탕으로 라이브러리를 고민해 볼 수 있을 것 같다. 현재 고민이 되었던 부분들은 충분히 이 책을 통해 해결하였다고 할 수 있다. 다만, 이 외에도 더 많은 내용을 담고 있지만, 내가 고민했던 부분만 위주로 쓰다 보니 모든 내용을 포함하지는 못했다. 이 외에도 상태 관리에 대해 고민하고 있는 개발자라면 해당 도서가 아니더라도 상태 관리와 관련된 서적은 한번 읽어보면 좋을 것 같다. ",
    tistory: "#",
  },

  {
    id: "9791169211567",
    updatedAt: 20250925,
    author: "우아한 형제들",
    title: "우아한 타입스크립트 with 리액트",
    description:
      "If we use TypeScript, let's write it the TypeScript way. 책을 읽기 전, 내가 생각하기에 타입스크립트가 지향하는 핵심 중 하나는 타입 안정성이다. 자바스크립트는 동적 타입 때문에 런타임에서 오류가 발생할 수 있지만,타입스크립트는 컴파일 단계에서 이를 잡아 비교적 안전하게 애플리케이션을 개발할 수 있다. 또한 타입 추론을 바탕으로 자동 완성 기능을 제공하여 안전하고 빠르게 개발을 할 수 있도록 지원하고 있다. 이러한 이점을 바탕으로, 나는 타입스크립트를 사용하면서 몇 가지 고민이 있었다. 첫번째. 타입스크립트를 사용하는 목적에 맞게 잘 사용하고 있는가?, 두번쨰. 실무에서는 타입스크립트를 어떻게 활용하고 있는가?, 세번째. 제네릭 타입ㅡ 세 가지의 고민을 중심으로 관련 서적을 읽기 시작했다. 지난 경험을 돌아보면, API 응답 데이터 구조에서 제네릭을 활용하는 예제들을 많이 보았으나 프로젝트에 직접 적용하는 일은 익숙치 않았다. 그래서 해당 포트폴리오의 getProjectApi 함수에서 APIRESPONSE<ProjectData[]>라는 제네릭 타입을 적용하여, 이를 통해 API 성공/실패 구조를 명확하게 타입으로 표현할 수 있었고, 호출하는 쪽에서 res.success와 같은 안전한 분기를 구현할 수 있었습니다. 현재 프로젝트에서는 API 호출이 project 데이터에 국한 되어 있지만, 규모가 커졌을 경우에 응답 데이터 구조만 다르게 하여 APIRESPONSE<BookData[]> 와 같이 재사용할 수 있는 가능성을 확인할 수 있었다. 이 외에도 제네릭과 관련된 예제들이 책에 많이 소개되어 있고 충분히 활용할 만한 부분들도 많이 보인다. 실무에서의 타입스크립트 활용하는 부분 중에서는 각 팀 컨벤션에 따라 활용하는 방법들이 다름을 보여주고 의견까지 상호교환 하는 부분이 인상적으로 남는다. 그 중에서 interface 와 type 을 쓰는 부분 그리고 Enum 타입 활용 부분에 대해 기억에 남는데, 나의 경우에는 기준을 정해서 interface와 type을 구분해서 사용하고 있다? 라고 생각해 본 적은 없지만, 되돌아 보면 interface를 객체 데이터 구조를 정의할 때 사용하고 있고 type 같은 경우는 원시 값 즉 정적인 값을 정의 할 때 주로 사용하고 있다. Enum 타입의 경우에는 값과 타입을 동시에 다룰 수 있다는 장점이 있지만, 지금까지 진행한 프로젝트에서는 필요성을 뚜렷하게 느끼지 못해 직접 사용한 경험은 없다. 다만 이는 실제로 필요하지 않았을 수도 있고, 혹은 내가 그 필요성을 충분히 캐치하지 못했을 수도 있다. 지속적으로 다양한 사례와 코드를 접하며 Enum을 어떻게 활용할 수 있을지 생각하고, 실제로 적용해 본 이후에 보다 명확한 관점으로 그 필요성과 장점을 설명할 수 있을것이라 생각한다. 자바스크립트는 동적 언어로서 타입을 자동 추론하는 경우가 있다. 이 때문에 타입을 모두 정의하지 않아도 애플리케이션이 개발은 될 수 있다. 그래서 .ts , .tsx 파일을 사용함에도 불구하고 any 타입으로 자동 추론되어 개발이 될 수도 있다. 이 부분은 tsconfig options 에서 noImplicitAny 을 설정하여 any 옵션을 막을 수 있다. 결국 타입스크립트는 코드의 안정성을 바탕으로 팀과의 협업 도구로써 활용되며, 도구를 어떻게 활용하는지 주체에 따라 차이가 크며, 보다 팀과 안전한 코드를 작성하기 위해서 끊임없이 고민하고 설계해야만 한다.",
    tistory: "#",
  },
  {
    id: "9791191600759",
    updatedAt: 20250102,
    author: "에릭 노드먼",
    title: "쏙쏙 들어오는 함수형 코딩",
    description: "#",
    tistory: "#",
  },
  {
    id: "9791158392239",
    updatedAt: 20250106,
    author: "이웅모",
    title: "모던 자바스크립트 Deep Dive",
    description: "#",
    tistory: "#",
  },
  {
    id: "9788966263745",
    updatedAt: 20250106,
    author: "윤동균",
    title: "프론트엔드 성능 최적화 가이드",
    description:
      "다양한 Animation을 포함한 포트폴리오를 만들고 돌아보니 페이지의 렌더링 속도가 현저히 느려지는 것을 보고 이때 최적화에 대한 관심을 자연스럽게 가지게 되었다. 물론 당시에 포트폴리오의 문제점은 보이지만 어떤 부분을 개선해야만 하는건지 짚어낼 수 조차 없었기에 최적화 정의부터 천천히 구글링을 통해 또는 책을 통해 학습해 나갔다. 그렇게 눈에 보이는 문제점 그리고 보이지 않던 문제점들이 더 많이 보이기 시작했다. 우선 Animation을 다양하게 포함하고 있기에 Performance 탭을 확인했을 때 많은 Animation 병목 현상이 발생하고 있음을 확인했다. 이 시기에 페이지가 어떻게 만들어지는지 브라우저 렌더링에 대한 부분을 깊게 헤아리게 되었던 것 같다. 일례로, Menu Tab들을 hover 했을 때 underline을 그려주는 Animation을 구현했던 부분도 width 값을 상태로 관리하면서 CSS에 직접 반영했는데, 이 방식이 리플로우와 리페인트를 유발했다. 여러 Animation 요소가 이러한 방식으로 동작하다 보니 겹겹이 쌓여 전체 렌더링 속도 저하로 이어졌다. 이후 해당 Animation을 transform scale 0 ~ 1 또는 opacity 0 ~ 1 과 같이 컴포지션 단계에서 처리되는 속성으로 변경하자, 리플로우와 리페인트를 일으키던 요소의 문제점을 해소할 수 있었다. 이 경험을 계기로 Animation을 GPU 컴포지션 단계에서 처리되도록 습관화하게 되었다. 이러한 부분이 Lighthouse 탭에서 FCP, LCP 와 같은 점수에 반영되고 이는 곧 사용자 경험(UX)로 직결됨을 배웠다. 이 외에도 FCP,LCP에 영향을 끼치는 부분은 다양했다. 코드 구조뿐만 아니라 이미지 파일, 동영상 파일, 네트워크 등 다양한 요소가 영향을 미친다는 점을 깨달았다. 결국, 내가 아는 만큼 문제점이 보이기 시작한다는 것을 이때 크게 체감할 수 있었다. 이상적으로는 프로젝트를 시작하기 전, 발생할 수 있는 문제를 예측하고 사전에 제거하는 것이 최선이겠지만 항상 그럴 수는 없다. 중요한 것은 발생한 문제를 정확히 인식하고 개선해 나가며 그 과정을 반복하는 것이다. 이를 통해 지식은 쌓이고, 단순히 “알고 있다”는 수준을 넘어 실제 코드에 자연스럽게 적용되는 습관으로 자리 잡아야 한다고 느꼈다.",
    tistory: "https://endless-growth.tistory.com/56",
  },
];
